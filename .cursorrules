# Project Rules for Best of Ecom

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI, Radix UI, and Tailwind.

## Design System & Component Reuse

**CRITICAL: Always prioritize existing design library tokens and components before creating new ones.**

### Component Reuse Priority
1. **First**: Check if an existing AlignUI component in `components/ui/` can be used
2. **Second**: Compose new sections/components from existing AlignUI components (buttons, checkboxes, inputs, etc.)
3. **Third**: Only create custom components if absolutely necessary, and always use AlignUI design tokens

### Design Token Usage
- **Always use AlignUI design tokens** from `tailwind.config.ts` instead of Tailwind defaults
- Use approved tokens for:
  - Typography: `text-title-h*`, `text-label-*`, `text-paragraph-*`, `text-subheading-*`
  - Colors: `bg-bg-*`, `text-text-*`, `border-stroke-*`, `bg-primary-*`, etc.
  - Shadows: `shadow-regular-*`, `shadow-button-*-focus`
  - Border radius: `rounded-lg`, `rounded-xl`, `rounded-10`, `rounded-20`
- **Never use** generic Tailwind classes like `text-lg`, `bg-white`, `shadow-md`, `text-gray-*`

### Component Decision Tree
When creating or modifying components:
1. Does AlignUI have an equivalent component? → Use AlignUI component
2. Can existing AlignUI components be composed? → Create composed component
3. Is this domain-specific and appropriate to be custom? → Use AlignUI design tokens

### Reusable Pattern Components
Always use existing pattern components when available:
- `LoadingState` - for loading indicators
- `EmptyState` - for empty states
- `ErrorState` - for error displays
- `Alert` - for notifications and messages

### Reference Documentation
- See `documentation/COMPONENT_LIBRARY_AUDIT.md` for approved component usage patterns
- See `tailwind.config.ts` for all available design tokens

## Code Style and Structure

- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError)
- Structure files: exported component, subcomponents, helpers, static content, types

## Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard)
- Favor named exports for components

## TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use maps instead
- Use functional components with TypeScript interfaces

## Syntax and Formatting

- Use the "function" keyword for pure functions
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements
- Use declarative JSX

## UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling
- Implement responsive design with Tailwind CSS; use a mobile-first approach

## Performance Optimization

- Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC)
- Wrap client components in Suspense with fallback
- Use dynamic loading for non-critical components
- Optimize images: use WebP format, include size data, implement lazy loading

## Server Components & Data Fetching

### Default to Server Components
- **Always start with Server Components** for pages that fetch data
- Only add `'use client'` when interactivity is required (forms, buttons, filters)
- Extract interactive parts to separate client components (e.g., `page-client.tsx`)

### Data Fetching Pattern
- **Server Components**: Fetch data directly using services (e.g., `getPageService()`)
- **Never use `useEffect` + `fetch` in page components** - this creates client-side waterfalls
- Use `loading.tsx` files for Suspense boundaries
- Always add `generateMetadata` for Server Component pages

### Error Handling
- Map external API errors to application error types at the query/client layer
- Supabase "not found" errors (code `PGRST116`) should throw `NotFoundError`
- Use `notFound()` from `next/navigation` in Server Components for 404s

### Optimistic UI Updates
- For filter interactions (checkboxes, dropdowns), use optimistic state with `useTransition`
- Update local state immediately, then sync with server via navigation
- Use `router.replace()` instead of `router.push()` for filter changes

### TypeScript Modules
- Empty TypeScript files must export at least one item (use `export {};` for placeholders)
- Never manually edit auto-generated files (e.g., `next-env.d.ts`)

### API Routes
- Prefer Server Components over API routes when possible
- API routes should only exist for external integrations or webhooks
- When removing API routes, ensure files are actually deleted from repository

**For detailed context and examples, see `documentation/LESSONS_LEARNED.md`**

## Key Conventions

- Use 'nuqs' for URL search parameter state management
- Optimize Web Vitals (LCP, CLS, FID)
- Limit 'use client':
  - Favor server components and Next.js SSR
  - Use only for Web API access in small components
  - Avoid for data fetching or state management

Follow Next.js docs for Data Fetching, Rendering, and Routing.
